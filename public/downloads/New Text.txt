(A) Implementation of interprocess communication

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>     
#include <pthread.h>
#include <semaphore.h>
#include <time.h>

#define BUFFER_SIZE 5
#define NUM_ITEMS 10

int buffer[BUFFER_SIZE];
int in = 0;   
int out = 0;   

sem_t empty;  
sem_t full;   
pthread_mutex_t mutex;  

void *producer(void *arg) {
    int item;
    for (int i = 0; i < NUM_ITEMS; ++i) {
         
        item = rand() % 100;  

        sem_wait(&empty);            
        pthread_mutex_lock(&mutex);   

        buffer[in] = item;
        printf("Producer: produced %d at buffer[%d]\n", item, in);
        in = (in + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex); 
        sem_post(&full);               

        sleep(1);  
    }
    return NULL;
}

void *consumer(void *arg) {
    int item;
    for (int i = 0; i < NUM_ITEMS; ++i) {
        sem_wait(&full);              
        pthread_mutex_lock(&mutex);   

        item = buffer[out];
        printf("Consumer: consumed %d from buffer[%d]\n", item, out);
        out = (out + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex);  
        sem_post(&empty);              

        sleep(2); 
    }
    return NULL;
}

int main(void) {
    pthread_t tid_producer, tid_consumer;

    srand(time(NULL));
 
    sem_init(&empty, 0, BUFFER_SIZE); 
    sem_init(&full, 0, 0);             
    pthread_mutex_init(&mutex, NULL);
 
    if (pthread_create(&tid_producer, NULL, producer, NULL) != 0) {
        perror("Failed to create producer thread");
        exit(1);
    }
    if (pthread_create(&tid_consumer, NULL, consumer, NULL) != 0) {
        perror("Failed to create consumer thread");
        exit(1);
    }
 
    pthread_join(tid_producer, NULL);
    pthread_join(tid_consumer, NULL);
 
    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);

    return 0;
}


(B) IPC using semaphore readers and writers problem

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>

#define NUM_READERS 5
#define NUM_WRITERS 3
#define READS_PER_READER 3
#define WRITES_PER_WRITER 3

sem_t mutex; 
sem_t wrt;    
int readcount = 0;
int shared_data = 0;

void *reader(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i < READS_PER_READER; ++i) { 
        sem_wait(&mutex);
        readcount++;
        if (readcount == 1) { 
            sem_wait(&wrt);
        }
        sem_post(&mutex);
 
        printf("Reader %d: read shared_data = %d\n", id, shared_data);
        sleep(1);  
 
        sem_wait(&mutex);
        readcount--;
        if (readcount == 0) { 
            sem_post(&wrt);
        }
        sem_post(&mutex);
 
        usleep((rand() % 500 + 100) * 1000);  
    }
    return NULL;
}

void *writer(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i < WRITES_PER_WRITER; ++i) {
  
        sem_wait(&wrt);
 
        shared_data += 1;
        printf("Writer %d: wrote shared_data = %d\n", id, shared_data);
        sleep(1);  
 
        sem_post(&wrt);
 
        usleep((rand() % 700 + 200) * 1000); 
    }
    return NULL;
}

int main(void) {
    srand(time(NULL));
    pthread_t rthreads[NUM_READERS], wthreads[NUM_WRITERS];
    int rids[NUM_READERS], wids[NUM_WRITERS];
 
    sem_init(&mutex, 0, 1);  
    sem_init(&wrt, 0, 1);    
 
    for (int i = 0; i < NUM_READERS; ++i) {
        rids[i] = i + 1;
        if (pthread_create(&rthreads[i], NULL, reader, &rids[i]) != 0) {
            perror("pthread_create reader");
            exit(1);
        }
    }
 
    for (int i = 0; i < NUM_WRITERS; ++i) {
        wids[i] = i + 1;
        if (pthread_create(&wthreads[i], NULL, writer, &wids[i]) != 0) {
            perror("pthread_create writer");
            exit(1);
        }
    }
 
    for (int i = 0; i < NUM_READERS; ++i) pthread_join(rthreads[i], NULL);
    for (int i = 0; i < NUM_WRITERS; ++i) pthread_join(wthreads[i], NULL);
 
    sem_destroy(&mutex);
    sem_destroy(&wrt);

    printf("All threads finished. Final shared_data = %d\n", shared_data);
    return 0;
}

(C) IPC using semaphore Dining Philosopher Problem

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#define N 5
#define MAX_EAT 3
#define THINKING 0
#define HUNGRY   1
#define EATING   2

sem_t mutex;
sem_t S[N];
int state[N];
int phil[N] = {0, 1, 2, 3, 4};
int eat_count[N] = {0};

void *philosopher(void *num);
void take_fork(int phnum);
void put_fork(int phnum);
void test(int phnum);

int left(int phnum) { return (phnum + 4) % N; }
int right(int phnum) { return (phnum + 1) % N; }

int main() {
    int i;
    pthread_t thread_id[N];

    sem_init(&mutex, 0, 1);
    for (i = 0; i < N; i++) {
        sem_init(&S[i], 0, 0);
    }

    for (i = 0; i < N; i++) {
        pthread_create(&thread_id[i], NULL, philosopher, &phil[i]);
        printf("Philosopher %d is THINKING\n", i + 1);
    }

    for (i = 0; i < N; i++) {
        pthread_join(thread_id[i], NULL);
    }

    printf("All philosophers have finished eating %d times each.\n", MAX_EAT);
    return 0;
}

void *philosopher(void *num) {
    int *i = num;

    while (eat_count[*i] < MAX_EAT) {
        sleep(1);
        take_fork(*i);
        sleep(2);
        put_fork(*i);
        eat_count[*i]++;
    }
    return NULL;
}

void take_fork(int phnum) {
    sem_wait(&mutex);
    state[phnum] = HUNGRY;
    printf("Philosopher %d is HUNGRY\n", phnum + 1);
    test(phnum);
    sem_post(&mutex);
    sem_wait(&S[phnum]);
    sleep(1);
}

void put_fork(int phnum) {
    sem_wait(&mutex);
    state[phnum] = THINKING;
    printf("Philosopher %d puts down forks and starts THINKING\n", phnum + 1);
    test(left(phnum));
    test(right(phnum));
    sem_post(&mutex);
}

void test(int phnum) {
    if (state[phnum] == HUNGRY &&
        state[left(phnum)] != EATING &&
        state[right(phnum)] != EATING) {
        state[phnum] = EATING;
        printf("Philosopher %d takes forks and starts EATING (Meal %d)\n",
               phnum + 1, eat_count[phnum] + 1);
        sem_post(&S[phnum]);
    }
}

(D) Implementation of IPC Using Pipes

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
int main() {
	int fd[2];
	pid_t pid;
	char write_msg[] = "Hello from Parent to Child via Pipe!";
	char read_msg[100];
	if (pipe(fd) == -1) {
		perror("pipe");
		exit(1);
	}
	pid = fork();
	if (pid < 0) {
		perror("fork");
		exit(1);
	}
	if (pid > 0) {
		close(fd[0]);
		write(fd[1], write_msg, strlen(write_msg) + 1);
		close(fd[1]);
	} else {

		close(fd[1]);
		read(fd[0], read_msg, sizeof(read_msg));
		printf("Child received: %s\n", read_msg);
		close(fd[0]);
	}
	return 0;
}
