IPC using semaphore Dining Philosopher Problem

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#define N 5
#define MAX_EAT 3
#define THINKING 0
#define HUNGRY   1
#define EATING   2

sem_t mutex;
sem_t S[N];
int state[N];
int phil[N] = {0, 1, 2, 3, 4};
int eat_count[N] = {0};

void *philosopher(void *num);
void take_fork(int phnum);
void put_fork(int phnum);
void test(int phnum);

int left(int phnum) { return (phnum + 4) % N; }
int right(int phnum) { return (phnum + 1) % N; }

int main() {
    int i;
    pthread_t thread_id[N];

    sem_init(&mutex, 0, 1);
    for (i = 0; i < N; i++) {
        sem_init(&S[i], 0, 0);
    }

    for (i = 0; i < N; i++) {
        pthread_create(&thread_id[i], NULL, philosopher, &phil[i]);
        printf("Philosopher %d is THINKING\n", i + 1);
    }

    for (i = 0; i < N; i++) {
        pthread_join(thread_id[i], NULL);
    }

    printf("All philosophers have finished eating %d times each.\n", MAX_EAT);
    return 0;
}

void *philosopher(void *num) {
    int *i = num;

    while (eat_count[*i] < MAX_EAT) {
        sleep(1);
        take_fork(*i);
        sleep(2);
        put_fork(*i);
        eat_count[*i]++;
    }
    return NULL;
}

void take_fork(int phnum) {
    sem_wait(&mutex);
    state[phnum] = HUNGRY;
    printf("Philosopher %d is HUNGRY\n", phnum + 1);
    test(phnum);
    sem_post(&mutex);
    sem_wait(&S[phnum]);
    sleep(1);
}

void put_fork(int phnum) {
    sem_wait(&mutex);
    state[phnum] = THINKING;
    printf("Philosopher %d puts down forks and starts THINKING\n", phnum + 1);
    test(left(phnum));
    test(right(phnum));
    sem_post(&mutex);
}

void test(int phnum) {
    if (state[phnum] == HUNGRY &&
        state[left(phnum)] != EATING &&
        state[right(phnum)] != EATING) {
        state[phnum] = EATING;
        printf("Philosopher %d takes forks and starts EATING (Meal %d)\n",
               phnum + 1, eat_count[phnum] + 1);
        sem_post(&S[phnum]);
    }
}

IPC using semaphore readers and writers problem

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>

#define NUM_READERS 5
#define NUM_WRITERS 3
#define READS_PER_READER 3
#define WRITES_PER_WRITER 3

sem_t mutex; 
sem_t wrt;    
int readcount = 0;
int shared_data = 0;

void *reader(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i < READS_PER_READER; ++i) { 
        sem_wait(&mutex);
        readcount++;
        if (readcount == 1) { 
            sem_wait(&wrt);
        }
        sem_post(&mutex);
 
        printf("Reader %d: read shared_data = %d\n", id, shared_data);
        sleep(1);  
 
        sem_wait(&mutex);
        readcount--;
        if (readcount == 0) { 
            sem_post(&wrt);
        }
        sem_post(&mutex);
 
        usleep((rand() % 500 + 100) * 1000);  
    }
    return NULL;
}

void *writer(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i < WRITES_PER_WRITER; ++i) {
  
        sem_wait(&wrt);
 
        shared_data += 1;
        printf("Writer %d: wrote shared_data = %d\n", id, shared_data);
        sleep(1);  
 
        sem_post(&wrt);
 
        usleep((rand() % 700 + 200) * 1000); 
    }
    return NULL;
}

int main(void) {
    srand(time(NULL));
    pthread_t rthreads[NUM_READERS], wthreads[NUM_WRITERS];
    int rids[NUM_READERS], wids[NUM_WRITERS];
 
    sem_init(&mutex, 0, 1);  
    sem_init(&wrt, 0, 1);    
 
    for (int i = 0; i < NUM_READERS; ++i) {
        rids[i] = i + 1;
        if (pthread_create(&rthreads[i], NULL, reader, &rids[i]) != 0) {
            perror("pthread_create reader");
            exit(1);
        }
    }
 
    for (int i = 0; i < NUM_WRITERS; ++i) {
        wids[i] = i + 1;
        if (pthread_create(&wthreads[i], NULL, writer, &wids[i]) != 0) {
            perror("pthread_create writer");
            exit(1);
        }
    }
 
    for (int i = 0; i < NUM_READERS; ++i) pthread_join(rthreads[i], NULL);
    for (int i = 0; i < NUM_WRITERS; ++i) pthread_join(wthreads[i], NULL);
 
    sem_destroy(&mutex);
    sem_destroy(&wrt);

    printf("All threads finished. Final shared_data = %d\n", shared_data);
    return 0;
}

Implementation of interprocess communication

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>     
#include <pthread.h>
#include <semaphore.h>
#include <time.h>

#define BUFFER_SIZE 5
#define NUM_ITEMS 10

int buffer[BUFFER_SIZE];
int in = 0;   
int out = 0;   

sem_t empty;  
sem_t full;   
pthread_mutex_t mutex;  

void *producer(void *arg) {
    int item;
    for (int i = 0; i < NUM_ITEMS; ++i) {
         
        item = rand() % 100;  

        sem_wait(&empty);            
        pthread_mutex_lock(&mutex);   

        buffer[in] = item;
        printf("Producer: produced %d at buffer[%d]\n", item, in);
        in = (in + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex); 
        sem_post(&full);               

        sleep(1);  
    }
    return NULL;
}

void *consumer(void *arg) {
    int item;
    for (int i = 0; i < NUM_ITEMS; ++i) {
        sem_wait(&full);              
        pthread_mutex_lock(&mutex);   

        item = buffer[out];
        printf("Consumer: consumed %d from buffer[%d]\n", item, out);
        out = (out + 1) % BUFFER_SIZE;

        pthread_mutex_unlock(&mutex);  
        sem_post(&empty);              

        sleep(2); 
    }
    return NULL;
}

int main(void) {
    pthread_t tid_producer, tid_consumer;

    srand(time(NULL));
 
    sem_init(&empty, 0, BUFFER_SIZE); 
    sem_init(&full, 0, 0);             
    pthread_mutex_init(&mutex, NULL);
 
    if (pthread_create(&tid_producer, NULL, producer, NULL) != 0) {
        perror("Failed to create producer thread");
        exit(1);
    }
    if (pthread_create(&tid_consumer, NULL, consumer, NULL) != 0) {
        perror("Failed to create consumer thread");
        exit(1);
    }
 
    pthread_join(tid_producer, NULL);
    pthread_join(tid_consumer, NULL);
 
    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);

    return 0;
}

Implementation of IPC Using Pipes

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
int main() {
int fd[2];  
pid_t pid;
char write_msg[] = "Hello from Parent to Child via Pipe!";
char read_msg[100]; 
if (pipe(fd) == -1) {
perror("pipe");
exit(1);
} 
pid = fork();
if (pid < 0) {
perror("fork");
exit(1);
}
if (pid > 0) { 
close(fd[0]);  
write(fd[1], write_msg, strlen(write_msg) + 1);
close(fd[1]);  
} else {
 
close(fd[1]);  
read(fd[0], read_msg, sizeof(read_msg));
printf("Child received: %s\n", read_msg);
close(fd[0]);  
}
return 0;
}


Implementation of Deadlock Prevention Using Bankerâ€™s Algorithm

#include <stdio.h>
#include <stdbool.h>
int main() {
int n, m, i, j, k;
printf("Enter number of processes: ");
scanf("%d", &n);
printf("Enter number of resources: ");
scanf("%d", &m);
int alloc[n][m], max[n][m], avail[m];
printf("Enter allocation matrix:\n");
for (i = 0; i < n; i++)
for (j = 0; j < m; j++)
scanf("%d", &alloc[i][j]);
printf("Enter maximum need matrix:\n");
for (i = 0; i < n; i++)
for (j = 0; j < m; j++)
scanf("%d", &max[i][j]);
printf("Enter available resources:\n");
for (j = 0; j < m; j++)
scanf("%d", &avail[j]);
int f[n], ans[n], ind = 0;
for (k = 0; k < n; k++) f[k] = 0;
int need[n][m];
for (i = 0; i < n; i++)
for (j = 0; j < m; j++)
need[i][j] = max[i][j] - alloc[i][j];
// Safety algorithm
int y = 0;
for (k = 0; k < n; k++) {
for (i = 0; i < n; i++) {
if (f[i] == 0) {
bool flag = true;
for (j = 0; j < m; j++) {
if (need[i][j] > avail[j]) {
flag = false;
break;
}
}
if (flag) {
ans[ind++] = i;
for (y = 0; y < m; y++)
avail[y] += alloc[i][y];
f[i] = 1;
}
}
}
}
bool safe = true;
for (i = 0; i < n; i++) {
if (f[i] == 0) {
safe = false;
printf("System is NOT in a safe state.\n");
break;
}
}
if (safe) {
printf("System is in a SAFE state.\nSafe sequence: ");
for (i = 0; i < n - 1; i++)
printf("P%d -> ", ans[i]);
printf("P%d\n", ans[n - 1]);
}
return 0;
}








Implementation of Memory Management Using Paging

#include <stdio.h>
int main() {
	int mem_size, page_size, no_of_pages, no_of_frames, frame[50], page_table[50];
	int i, j, logical_addr, page_no, frame_no, offset, physical_addr;
	printf("Enter the memory size (in KB): ");
	scanf("%d", &mem_size);
	printf("Enter the page size (in KB): ");
	scanf("%d", &page_size);
	no_of_frames = mem_size / page_size;
	no_of_pages = no_of_frames;  
	printf("\nMemory divided into %d frames\n", no_of_frames);
	printf("Process divided into %d pages\n", no_of_pages); 
	printf("\nEnter the frame number where each page is stored (-1 if not present):\n");
	for (i = 0; i < no_of_pages; i++) {
		printf("Page %d b -> Frame: ", i);
		scanf("%d", &page_table[i]);
	} 
	printf("\nEnter a logical address (Page number and Offset):\n");
	printf("Page number: ");
	scanf("%d", &page_no);
	printf("Offset: ");
	scanf("%d", &offset);
	if (page_no >= no_of_pages || page_table[page_no] == -1) {
		printf("\nInvalid page reference b -> Page Fault occurred!\n");
	} else {
		frame_no = page_table[page_no];
		physical_addr = frame_no * page_size + offset;
		printf("\nLogical Address b -> (Page: %d, Offset: %d)", page_no, offset);
		printf("\nPhysical Address b -> %d\n", physical_addr);
	}
	return 0;
}